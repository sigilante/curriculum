#   App School Live

![](https://raw.githubusercontent.com/sigilante/curriculum/master/curr-asl.png)

App School Live teaches developers how to build applications using Urbit, including CLI and front-end agents.

Cohorts will run aiming for three cohorts per year.

There will be an accelerated workshop-based version for use at conferences.

##  Agenda

- `bridge0`.  Upgrading Urbit Development (optional; not live)
- `lesson1`.  A Simple Agent
- `lesson2`.  Agents (Subscriptions etc.)
- `lesson3`.  Better Cores
- `lesson4`.  Passing Data (JSON+API)
- `lesson5`.  React Front-End
- `lesson6`.  Arvo Services
- `lesson7`.  Threads
- `lesson8`.  Production Apps

##  Teaching

Instructor + 1â€“2 teaching assistant(s)

Lots of short recorded videos

One livestream weekly for Q&A+HW solution

One homework per lesson

##  Objectives

### `bridge0`.  Upgrading Urbit Development

After the bridge lesson, you should be able to:

- Have access to Hoon syntax highlighting in your editor.
- Use the Urbit Language Server Protocol plugin.

### `lesson1`.  A Simple Agent.

After Lesson 1, you should be able to:

- Produce a minimalist Gall agent.
- Employ the `default-agent` library.
- Employ the `%dbug` agent wrapper.
- Define entropy and its source.
- Utilize `eny` in a random number generator (`og`).
- Distinguish insecure hashing (`mug`) from secure hashing (`shax` and friends).

### `lesson2`.  Agents.

After Lesson 2, you should be able to:

- Produce an advanced Gall agent without a front-end interface.
- Explain how subscriptions work and use them.

### `lesson3`.  Better Cores.

After Lesson 3, you should be able to:

- Distinguish dry and wet gates.
- Describe use cases for wet gates (using genericity).
- Enumerate and distinguish use cases for dry cores (using variance):
- - Covariant (`%zinc`)
- - Contravariant (`%iron`)
- - Bivariant (`%lead`)
- - Invariant (`%gold`)

You will know the runes:

- `|*`
- `|@`
- `^|`
- `^&`
- `^?`
- `|~`
- `|?`

### `lesson4`.  Passing Data.

After Lesson 4, you should be able to:

- Diagram how marks convert nouns.
- Explain the use of the `++grab`, `++grow`, and `++grad` arms.
- Produce a simple mark.
- Parse JSON input.
- Construct a JSON reparser.
- Convert JSON to other formats with a mark.
- Retrieve particular values from a JSON input.

You will know the runes:

- `/*`
- `;;`

### `lesson5`.  React Front-End.

After Lesson 5, you should be able to:

- Interact with Urbit using Airlock, by language.
- Produce an advanced agent with a front-end interface.
- Explain the role of a %glob and produce one.

### `lesson6`.  Arvo Services.

After Lesson 6, you should be able to:

- Explain Arvo as a state machine and event log.
- Explain Kelvin versioning and identify the system components that require this approach.
- Explain the services Ames provides to the system.
- Diagram the architecture of Ames as a network.
- Explain the services Behn provides to the system.
- Explain the services Clay provides to the system.
- Identify key Clay artifacts:  desks, marks, etc.
- Explain the services Dill provides to the system.
- Explain the services Eyre provides to the system.
- Explain the services Gall provides to the system.
- Explain the services Iris provides to the system.
- Explain the services Jael provides to the system.
- Enumerate the secrets Jael tracks.
- Explain the services Khan provides to the system.

You will know the runes:

- `/?`
- `!?`

### `lesson7`.  Threads.

After Lesson 7, you should be able to:

- Use Spider to dispatch and manage threads.

### `lesson8`.  Production Apps.

After Lesson 8, you should be able to:

- Run existing unit tests.
- Produce a unit test.
- Enumerate and identify advanced error messages (`mull-grow`, etc.).
- Produce a desk suitable for distribution (with a docket file).
- Install and distribute software.
- Explain elements of a docket file.
- Set up a continuous integration pipeline to test Gall agents and other published code.
